5) R - justify why it's ok for this method to have troubles with high heart rates
	a) wouldn't detect peaks anyways because data is not dense enough. Give bound for BPM with current data density.
6) Clean-up
	a) local.py
	b) services.py
10) R - justify not doing regression
12) R - compare fluctuations in bpm to fluctuations in actual heart_beat
13) develop method that matches setting not to BPM but also to fluctuations in bpm - not too difficult. more manual work.
17) get rid of dummies - LATER
21) google code formatting - LATER
22) add step 15 methods - DESIGN EXPERIMENT FIRST
23) rename step methods to be more intuitive - LATER
24) check out at_risk()
25) there is an affect of previous windows on later windows!
26) had to clean-up data
27) removal of min_spacing isn't working correctly -- ahh it's the bad data factor
28) figure out how to adjust the bad data factor for step2
29) check whether self.stuff ripples through
30) change bad_data to 0.75 or 0.8
31) 'on edges' problem could do good! -> i should only do bad data factor for inside the beats


3.5) clean-up
4) begin testing
5) improve step 1 method to contain beat shape or something


text_back
'empty' = power set empty
number = percentage BS

which methods 0,1,2
what were the benchmarks?
I want to iterate over methods

object CHOSEN
object of all methods or object per method?

window_length

EXPERIMENT 1
1) what do I want in test feedback?
	ROW = [bpm, bad_data_factor, at_risk, bad_data_bool, actual]
	a) bpm vs actual - avg-diff for good data only
	b) bad_data_factor - distribution
	c) at_risk - at_risk percentage
	d) bad_data_bool - compare ratio to actual ratio

2) figure out a way to loop through settings
EXPERIMENT 2
graph how window length affects data
graph warm-up time too